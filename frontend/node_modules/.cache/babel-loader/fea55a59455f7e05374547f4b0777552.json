{"ast":null,"code":"var _jsxFileName = \"/Users/buw0017/projects/TheBigLeagueGame/frontend/src/components/Table.js\";\nimport React, { Component } from \"react\";\nimport PropTypes from 'prop-types';\nimport Row from './Row';\nimport { Parser as FormulaParser } from 'hot-formula-parser';\nexport default class Table extends Component {\n  constructor(props) {\n    super(props);\n\n    this.handleChangedCell = ({\n      x,\n      y\n    }, value) => {\n      const modifiedData = Object.assign({}, this.state.data);\n      if (!modifiedData[y]) modifiedData[y] = {};\n      modifiedData[y][x] = value;\n      this.setState({\n        data: modifiedData\n      });\n\n      if (window && window.localStorage) {\n        window.localStorage.setItem(this.tableIdentifier, JSON.stringify(modifiedData));\n      }\n    };\n\n    this.updateCells = () => {\n      this.forceUpdate();\n    };\n\n    this.executeFormula = (cell, value) => {\n      this.parser.cell = cell;\n      let res = this.parser.parse(value);\n\n      if (res.error != null) {\n        return res; // tip: returning `res.error` shows more details\n      }\n\n      if (res.result.toString() === '') {\n        return res;\n      }\n\n      if (res.result.toString().slice(0, 1) === '=') {\n        // formula points to formula\n        res = this.executeFormula(cell, res.result.slice(1));\n      }\n\n      return res;\n    };\n\n    this.tableIdentifier = `tableData-${props.id}`;\n    this.parser = new FormulaParser(); // When a formula contains a cell value, this event lets us\n    // hook and return an error value if necessary\n\n    this.parser.on('callCellValue', (cellCoord, done) => {\n      const x = cellCoord.column.index + 1;\n      const y = cellCoord.row.index + 1; // Check if I have that coordinates tuple in the table range\n\n      if (x > this.props.x || y > this.props.y) {\n        throw this.parser.Error(this.parser.ERROR_NOT_AVAILABLE);\n      } // Check that the cell is not self referencing\n\n\n      if (this.parser.cell.x === x && this.parser.cell.y === y) {\n        throw this.parser.Error(this.parser.ERROR_REF);\n      }\n\n      if (!this.state.data[y] || !this.state.data[y][x]) {\n        return done('');\n      } // All fine\n\n\n      return done(this.state.data[y][x]);\n    }); // When a formula contains a range value, this event lets us\n    // hook and return an error value if necessary\n\n    this.parser.on('callRangeValue', (startCellCoord, endCellCoord, done) => {\n      const sx = startCellCoord.column.index + 1;\n      const sy = startCellCoord.row.index + 1;\n      const ex = endCellCoord.column.index + 1;\n      const ey = endCellCoord.row.index + 1;\n      const fragment = [];\n\n      for (let y = sy; y <= ey; y += 1) {\n        const row = this.state.data[y];\n\n        if (!row) {\n          continue;\n        }\n\n        const colFragment = [];\n\n        for (let x = sx; x <= ex; x += 1) {\n          let value = row[x];\n\n          if (!value) {\n            value = '';\n          }\n\n          if (value.slice(0, 1) === '=') {\n            const res = this.executeFormula({\n              x,\n              y\n            }, value.slice(1));\n\n            if (res.error) {\n              throw this.parser.Error(res.error);\n            }\n\n            value = res.result;\n          }\n\n          colFragment.push(value);\n        }\n\n        fragment.push(colFragment);\n      }\n\n      if (fragment) {\n        done(fragment);\n      }\n    });\n    this.state = {\n      data: {}\n    };\n  }\n  /**\n  * Do not save changes to cells\n  */\n  // handleChangedCell = ({ x, y }, value) => {\n  //   const modifiedData = Object.assign({}, this.state.data)\n  //   if (!modifiedData[y]) modifiedData[y] = {}\n  //   modifiedData[y][x] = value\n  //   this.setState({ data: modifiedData })\n  // }\n\n  /**\n  * Save changes to cells locally\n  */\n\n\n  componentWillMount() {\n    if (this.props.saveToLocalStorage && window && window.localStorage) {\n      const data = window.localStorage.getItem(this.tableIdentifier);\n\n      if (data) {\n        this.setState({\n          data: JSON.parse(data)\n        });\n      }\n    }\n  }\n\n  render() {\n    const rows = [];\n\n    for (let y = 0; y < this.props.y + 1; y += 1) {\n      const rowData = this.state.data[y] || {};\n      rows.push(React.createElement(Row, {\n        handleChangedCell: this.handleChangedCell,\n        updateCells: this.updateCells,\n        executeFormula: this.executeFormula,\n        key: y,\n        y: y,\n        x: this.props.x + 1,\n        rowData: rowData,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 147\n        },\n        __self: this\n      }));\n    }\n\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 159\n      },\n      __self: this\n    }, rows);\n  }\n\n}\nTable.propTypes = {\n  x: PropTypes.number.isRequired,\n  y: PropTypes.number.isRequired\n};","map":{"version":3,"sources":["/Users/buw0017/projects/TheBigLeagueGame/frontend/src/components/Table.js"],"names":["React","Component","PropTypes","Row","Parser","FormulaParser","Table","constructor","props","handleChangedCell","x","y","value","modifiedData","Object","assign","state","data","setState","window","localStorage","setItem","tableIdentifier","JSON","stringify","updateCells","forceUpdate","executeFormula","cell","parser","res","parse","error","result","toString","slice","id","on","cellCoord","done","column","index","row","Error","ERROR_NOT_AVAILABLE","ERROR_REF","startCellCoord","endCellCoord","sx","sy","ex","ey","fragment","colFragment","push","componentWillMount","saveToLocalStorage","getItem","render","rows","rowData","propTypes","number","isRequired"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport PropTypes from 'prop-types'\nimport Row from './Row'\nimport {Parser as FormulaParser} from 'hot-formula-parser';\n\n\n\nexport default class Table extends Component {\n  constructor(props) {\n    super(props)\n\n    this.tableIdentifier = `tableData-${props.id}`\n    this.parser = new FormulaParser()\n\n    // When a formula contains a cell value, this event lets us\n    // hook and return an error value if necessary\n    this.parser.on('callCellValue', (cellCoord, done) => {\n      const x = cellCoord.column.index + 1\n      const y = cellCoord.row.index + 1\n      // Check if I have that coordinates tuple in the table range\n      if (x > this.props.x || y > this.props.y) {\n        throw this.parser.Error(this.parser.ERROR_NOT_AVAILABLE)\n      }\n      // Check that the cell is not self referencing\n      if (this.parser.cell.x === x && this.parser.cell.y === y) {\n        throw this.parser.Error(this.parser.ERROR_REF)\n      }\n      if (!this.state.data[y] || !this.state.data[y][x]) {\n        return done('')\n      }\n      // All fine\n      return done(this.state.data[y][x])\n    })\n\n    // When a formula contains a range value, this event lets us\n    // hook and return an error value if necessary\n    this.parser.on('callRangeValue',\n      (startCellCoord, endCellCoord, done) => {\n      const sx = startCellCoord.column.index + 1\n      const sy = startCellCoord.row.index + 1\n      const ex = endCellCoord.column.index + 1\n      const ey = endCellCoord.row.index + 1\n      const fragment = []\n\n      for (let y = sy; y <= ey; y += 1) {\n        const row = this.state.data[y]\n        if (!row) {\n          continue\n        }\n\n        const colFragment = []\n\n        for (let x = sx; x <= ex; x += 1) {\n          let value = row[x]\n          if (!value) {\n            value = ''\n          }\n\n          if (value.slice(0, 1) === '=') {\n            const res = this.executeFormula({ x, y },\n              value.slice(1))\n            if (res.error) {\n              throw this.parser.Error(res.error)\n            }\n            value = res.result\n          }\n\n          colFragment.push(value)\n        }\n        fragment.push(colFragment)\n      }\n      if (fragment) {\n        done(fragment)\n            }\n    })\n    this.state = {\n      data: {},\n    }\n  }\n\n/**\n* Do not save changes to cells\n*/\n  // handleChangedCell = ({ x, y }, value) => {\n  //   const modifiedData = Object.assign({}, this.state.data)\n  //   if (!modifiedData[y]) modifiedData[y] = {}\n  //   modifiedData[y][x] = value\n  //   this.setState({ data: modifiedData })\n  // }\n/**\n* Save changes to cells locally\n*/\nhandleChangedCell = ({ x, y }, value) => {\n  const modifiedData = Object.assign({}, this.state.data)\n  if (!modifiedData[y]) modifiedData[y] = {}\n  modifiedData[y][x] = value\n  this.setState({ data: modifiedData })\n\n  if (window && window.localStorage) {\n    window.localStorage.setItem(this.tableIdentifier,\n      JSON.stringify(modifiedData))\n  }\n}\n\ncomponentWillMount() {\n  if (this.props.saveToLocalStorage &&\n      window &&\n      window.localStorage) {\n    const data = window.localStorage.getItem(this.tableIdentifier)\n    if (data) {\n      this.setState({ data: JSON.parse(data) })\n    }\n  }\n}\n\n  updateCells = () => {\n    this.forceUpdate()\n  }\n\n  /**\n   * Executes the formula on the `value` usign the\n   * FormulaParser object\n   */\n  executeFormula = (cell, value) => {\n    this.parser.cell = cell\n    let res = this.parser.parse(value)\n    if (res.error != null) {\n      return res // tip: returning `res.error` shows more details\n    }\n    if (res.result.toString() === '') {\n      return res\n    }\n    if (res.result.toString().slice(0, 1) === '=') {\n      // formula points to formula\n      res = this.executeFormula(cell, res.result.slice(1))\n    }\n\n    return res\n  }\n\n  render() {\n    const rows = []\n\n    for (let y = 0; y < this.props.y + 1; y += 1) {\n      const rowData = this.state.data[y] || {}\n      rows.push(\n        <Row\n          handleChangedCell={this.handleChangedCell}\n          updateCells={this.updateCells}\n          executeFormula={this.executeFormula}\n          key={y}\n          y={y}\n          x={this.props.x + 1}\n          rowData={rowData}\n        />,\n      )\n    }\n    return (\n      <div>\n        {rows}\n      </div>\n    )\n  }\n}\n\nTable.propTypes = {\n  x: PropTypes.number.isRequired,\n  y: PropTypes.number.isRequired,\n}"]},"metadata":{},"sourceType":"module"}