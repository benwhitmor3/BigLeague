{"ast":null,"code":"var _jsxFileName = \"/Users/buw0017/projects/TheBigLeagueGame/frontend/src/components/Table.js\";\nimport React, { Component } from \"react\";\nimport PropTypes from 'prop-types';\nimport Row from './Row';\nimport { Parser as FormulaParser } from 'hot-formula-parser';\nexport default class Table extends Component {\n  constructor(props) {\n    super(props);\n\n    this.updateCells = () => {\n      this.forceUpdate();\n    };\n\n    this.executeFormula = (cell, value) => {\n      this.parser.cell = cell;\n      let res = this.parser.parse(value);\n\n      if (res.error != null) {\n        return res; // tip: returning `res.error` shows more details\n      }\n\n      if (res.result.toString() === '') {\n        return res;\n      }\n\n      if (res.result.toString().slice(0, 1) === '=') {\n        // formula points to formula\n        res = this.executeFormula(cell, res.result.slice(1));\n      }\n\n      return res;\n    };\n\n    this.parser = new FormulaParser(); // When a formula contains a cell value, this event lets us\n    // hook and return an error value if necessary\n\n    this.parser.on('callCellValue', (cellCoord, done) => {\n      const x = cellCoord.column.index + 1;\n      const y = cellCoord.row.index + 1; // Check if I have that coordinates tuple in the table range\n\n      if (x > this.props.x || y > this.props.y) {\n        throw this.parser.Error(this.parser.ERROR_NOT_AVAILABLE);\n      } // Check that the cell is not self referencing\n\n\n      if (this.parser.cell.x === x && this.parser.cell.y === y) {\n        throw this.parser.Error(this.parser.ERROR_REF);\n      }\n\n      if (!this.state.data[y] || !this.state.data[y][x]) {\n        return done('');\n      } // All fine\n\n\n      return done(this.state.data[y][x]);\n    }); // When a formula contains a range value, this event lets us\n    // hook and return an error value if necessary\n\n    this.parser.on('callRangeValue', (startCellCoord, endCellCoord, done) => {\n      const sx = startCellCoord.column.index + 1;\n      const sy = startCellCoord.row.index + 1;\n      const ex = endCellCoord.column.index + 1;\n      const ey = endCellCoord.row.index + 1;\n      const fragment = [];\n\n      for (let y = sy; y <= ey; y += 1) {\n        const row = this.state.data[y];\n\n        if (!row) {\n          continue;\n        }\n\n        const colFragment = [];\n\n        for (let x = sx; x <= ex; x += 1) {\n          let value = row[x];\n\n          if (!value) {\n            value = '';\n          }\n\n          if (value.slice(0, 1) === '=') {\n            const res = this.executeFormula({\n              x,\n              y\n            }, value.slice(1));\n\n            if (res.error) {\n              throw this.parser.Error(res.error);\n            }\n\n            value = res.result;\n          }\n\n          colFragment.push(value);\n        }\n\n        fragment.push(colFragment);\n      }\n\n      if (fragment) {\n        done(fragment);\n      }\n    });\n    this.state = {\n      data: {}\n    };\n  }\n  /**\n   * Do not save changes to cells\n   */\n  // handleChangedCell = ({ x, y }, value) => {\n  //   const modifiedData = Object.assign({}, this.state.data)\n  //   if (!modifiedData[y]) modifiedData[y] = {}\n  //   modifiedData[y][x] = value\n  //   this.setState({ data: modifiedData })\n  // }\n\n\n  render() {\n    const rows = [];\n\n    for (let y = 0; y < this.props.y + 1; y += 1) {\n      const rowData = this.state.data[y] || {};\n      rows.push(React.createElement(Row, {\n        handleChangedCell: this.handleChangedCell,\n        updateCells: this.updateCells,\n        executeFormula: this.executeFormula,\n        key: y,\n        y: y,\n        x: this.props.x + 1,\n        rowData: rowData,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 121\n        },\n        __self: this\n      }));\n    }\n\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 133\n      },\n      __self: this\n    }, rows);\n  }\n\n}\nTable.propTypes = {\n  x: PropTypes.number.isRequired,\n  y: PropTypes.number.isRequired\n};","map":{"version":3,"sources":["/Users/buw0017/projects/TheBigLeagueGame/frontend/src/components/Table.js"],"names":["React","Component","PropTypes","Row","Parser","FormulaParser","Table","constructor","props","updateCells","forceUpdate","executeFormula","cell","value","parser","res","parse","error","result","toString","slice","on","cellCoord","done","x","column","index","y","row","Error","ERROR_NOT_AVAILABLE","ERROR_REF","state","data","startCellCoord","endCellCoord","sx","sy","ex","ey","fragment","colFragment","push","render","rows","rowData","handleChangedCell","propTypes","number","isRequired"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport PropTypes from 'prop-types'\nimport Row from './Row'\nimport {Parser as FormulaParser} from 'hot-formula-parser';\n\n\n\nexport default class Table extends Component {\n  constructor(props) {\n    super(props)\n\n    this.parser = new FormulaParser()\n\n    // When a formula contains a cell value, this event lets us\n    // hook and return an error value if necessary\n    this.parser.on('callCellValue', (cellCoord, done) => {\n      const x = cellCoord.column.index + 1\n      const y = cellCoord.row.index + 1\n      // Check if I have that coordinates tuple in the table range\n      if (x > this.props.x || y > this.props.y) {\n        throw this.parser.Error(this.parser.ERROR_NOT_AVAILABLE)\n      }\n      // Check that the cell is not self referencing\n      if (this.parser.cell.x === x && this.parser.cell.y === y) {\n        throw this.parser.Error(this.parser.ERROR_REF)\n      }\n      if (!this.state.data[y] || !this.state.data[y][x]) {\n        return done('')\n      }\n      // All fine\n      return done(this.state.data[y][x])\n    })\n\n    // When a formula contains a range value, this event lets us\n    // hook and return an error value if necessary\n    this.parser.on('callRangeValue',\n      (startCellCoord, endCellCoord, done) => {\n      const sx = startCellCoord.column.index + 1\n      const sy = startCellCoord.row.index + 1\n      const ex = endCellCoord.column.index + 1\n      const ey = endCellCoord.row.index + 1\n      const fragment = []\n\n      for (let y = sy; y <= ey; y += 1) {\n        const row = this.state.data[y]\n        if (!row) {\n          continue\n        }\n\n        const colFragment = []\n\n        for (let x = sx; x <= ex; x += 1) {\n          let value = row[x]\n          if (!value) {\n            value = ''\n          }\n\n          if (value.slice(0, 1) === '=') {\n            const res = this.executeFormula({ x, y },\n              value.slice(1))\n            if (res.error) {\n              throw this.parser.Error(res.error)\n            }\n            value = res.result\n          }\n\n          colFragment.push(value)\n        }\n        fragment.push(colFragment)\n      }\n      if (fragment) {\n        done(fragment)\n            }\n    })\n    this.state = {\n      data: {},\n    }\n  }\n\n  /**\n   * Do not save changes to cells\n   */\n  // handleChangedCell = ({ x, y }, value) => {\n  //   const modifiedData = Object.assign({}, this.state.data)\n  //   if (!modifiedData[y]) modifiedData[y] = {}\n  //   modifiedData[y][x] = value\n  //   this.setState({ data: modifiedData })\n  // }\n\n  updateCells = () => {\n    this.forceUpdate()\n  }\n\n  /**\n   * Executes the formula on the `value` usign the\n   * FormulaParser object\n   */\n  executeFormula = (cell, value) => {\n    this.parser.cell = cell\n    let res = this.parser.parse(value)\n    if (res.error != null) {\n      return res // tip: returning `res.error` shows more details\n    }\n    if (res.result.toString() === '') {\n      return res\n    }\n    if (res.result.toString().slice(0, 1) === '=') {\n      // formula points to formula\n      res = this.executeFormula(cell, res.result.slice(1))\n    }\n\n    return res\n  }\n\n  render() {\n    const rows = []\n\n    for (let y = 0; y < this.props.y + 1; y += 1) {\n      const rowData = this.state.data[y] || {}\n      rows.push(\n        <Row\n          handleChangedCell={this.handleChangedCell}\n          updateCells={this.updateCells}\n          executeFormula={this.executeFormula}\n          key={y}\n          y={y}\n          x={this.props.x + 1}\n          rowData={rowData}\n        />,\n      )\n    }\n    return (\n      <div>\n        {rows}\n      </div>\n    )\n  }\n}\n\nTable.propTypes = {\n  x: PropTypes.number.isRequired,\n  y: PropTypes.number.isRequired,\n}"]},"metadata":{},"sourceType":"module"}