{"ast":null,"code":"var _jsxFileName = \"/Users/buw0017/projects/TheBigLeagueGame/frontend/src/components/Table.js\";\nimport React, { Component } from \"react\";\nimport PropTypes from 'prop-types';\nimport Row from './Row';\nimport { Parser as FormulaParser } from 'hot-formula-parser';\nexport default class Table extends Component {\n  constructor(props) {\n    super(props);\n\n    this.handleChangedCell = ({\n      x,\n      y\n    }, value) => {\n      const modifiedData = Object.assign({}, this.state.data);\n      if (!modifiedData[y]) modifiedData[y] = {};\n      modifiedData[y][x] = value;\n      this.setState({\n        data: modifiedData\n      });\n    };\n\n    this.updateCells = () => {\n      this.forceUpdate();\n    };\n\n    this.parser = new FormulaParser(); // When a formula contains a cell value, this event lets us\n    // hook and return an error value if necessary\n\n    this.parser.on('callCellValue', (cellCoord, done) => {\n      const x = cellCoord.column.index + 1;\n      const y = cellCoord.row.index + 1; // Check if I have that coordinates tuple in the table range\n\n      if (x > this.props.x || y > this.props.y) {\n        throw this.parser.Error(this.parser.ERROR_NOT_AVAILABLE);\n      } // Check that the cell is not self referencing\n\n\n      if (this.parser.cell.x === x && this.parser.cell.y === y) {\n        throw this.parser.Error(this.parser.ERROR_REF);\n      }\n\n      if (!this.state.data[y] || !this.state.data[y][x]) {\n        return done('');\n      } // All fine\n\n\n      return done(this.state.data[y][x]);\n    }); // When a formula contains a range value, this event lets us\n    // hook and return an error value if necessary\n\n    this.parser.on('callRangeValue', (startCellCoord, endCellCoord, done) => {\n      const sx = startCellCoord.column.index + 1;\n      const sy = startCellCoord.row.index + 1;\n      const ex = endCellCoord.column.index + 1;\n      const ey = endCellCoord.row.index + 1;\n      const fragment = [];\n\n      for (let y = sy; y <= ey; y += 1) {\n        const row = this.state.data[y];\n\n        if (!row) {\n          continue;\n        }\n\n        const colFragment = [];\n\n        for (let x = sx; x <= ex; x += 1) {\n          let value = row[x];\n\n          if (!value) {\n            value = '';\n          }\n\n          if (value.slice(0, 1) === '=') {\n            const res = this.executeFormula({\n              x,\n              y\n            }, value.slice(1));\n\n            if (res.error) {\n              throw this.parser.Error(res.error);\n            }\n\n            value = res.result;\n          }\n\n          colFragment.push(value);\n        }\n\n        fragment.push(colFragment);\n      }\n\n      if (fragment) {\n        done(fragment);\n      }\n    });\n    this.state = {\n      data: {}\n    };\n  }\n\n  render() {\n    const rows = [];\n\n    for (let y = 0; y < this.props.y + 1; y += 1) {\n      const rowData = this.state.data[y] || {};\n      rows.push(React.createElement(Row, {\n        handleChangedCell: this.handleChangedCell,\n        updateCells: this.updateCells,\n        key: y,\n        y: y,\n        x: this.props.x + 1,\n        rowData: rowData,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 97\n        },\n        __self: this\n      }));\n    }\n\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 108\n      },\n      __self: this\n    }, rows);\n  }\n\n}\nTable.propTypes = {\n  x: PropTypes.number.isRequired,\n  y: PropTypes.number.isRequired\n};","map":{"version":3,"sources":["/Users/buw0017/projects/TheBigLeagueGame/frontend/src/components/Table.js"],"names":["React","Component","PropTypes","Row","Parser","FormulaParser","Table","constructor","props","handleChangedCell","x","y","value","modifiedData","Object","assign","state","data","setState","updateCells","forceUpdate","parser","on","cellCoord","done","column","index","row","Error","ERROR_NOT_AVAILABLE","cell","ERROR_REF","startCellCoord","endCellCoord","sx","sy","ex","ey","fragment","colFragment","slice","res","executeFormula","error","result","push","render","rows","rowData","propTypes","number","isRequired"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport PropTypes from 'prop-types'\nimport Row from './Row'\nimport {Parser as FormulaParser} from 'hot-formula-parser';\n\n\n\nexport default class Table extends Component {\n  constructor(props) {\n    super(props)\n\n    this.parser = new FormulaParser()\n\n    // When a formula contains a cell value, this event lets us\n    // hook and return an error value if necessary\n    this.parser.on('callCellValue', (cellCoord, done) => {\n      const x = cellCoord.column.index + 1\n      const y = cellCoord.row.index + 1\n      // Check if I have that coordinates tuple in the table range\n      if (x > this.props.x || y > this.props.y) {\n        throw this.parser.Error(this.parser.ERROR_NOT_AVAILABLE)\n      }\n      // Check that the cell is not self referencing\n      if (this.parser.cell.x === x && this.parser.cell.y === y) {\n        throw this.parser.Error(this.parser.ERROR_REF)\n      }\n      if (!this.state.data[y] || !this.state.data[y][x]) {\n        return done('')\n      }\n      // All fine\n      return done(this.state.data[y][x])\n    })\n\n    // When a formula contains a range value, this event lets us\n    // hook and return an error value if necessary\n    this.parser.on('callRangeValue',\n      (startCellCoord, endCellCoord, done) => {\n      const sx = startCellCoord.column.index + 1\n      const sy = startCellCoord.row.index + 1\n      const ex = endCellCoord.column.index + 1\n      const ey = endCellCoord.row.index + 1\n      const fragment = []\n\n      for (let y = sy; y <= ey; y += 1) {\n        const row = this.state.data[y]\n        if (!row) {\n          continue\n        }\n\n        const colFragment = []\n\n        for (let x = sx; x <= ex; x += 1) {\n          let value = row[x]\n          if (!value) {\n            value = ''\n          }\n\n          if (value.slice(0, 1) === '=') {\n            const res = this.executeFormula({ x, y },\n              value.slice(1))\n            if (res.error) {\n              throw this.parser.Error(res.error)\n            }\n            value = res.result\n          }\n\n          colFragment.push(value)\n        }\n        fragment.push(colFragment)\n      }\n      if (fragment) {\n        done(fragment)\n            }\n    })\n    this.state = {\n      data: {},\n    }\n  }\n\n  handleChangedCell = ({ x, y }, value) => {\n    const modifiedData = Object.assign({}, this.state.data)\n    if (!modifiedData[y]) modifiedData[y] = {}\n    modifiedData[y][x] = value\n    this.setState({ data: modifiedData })\n  }\n\n  updateCells = () => {\n    this.forceUpdate()\n  }\n\n  render() {\n    const rows = []\n\n    for (let y = 0; y < this.props.y + 1; y += 1) {\n      const rowData = this.state.data[y] || {}\n      rows.push(\n        <Row\n          handleChangedCell={this.handleChangedCell}\n          updateCells={this.updateCells}\n          key={y}\n          y={y}\n          x={this.props.x + 1}\n          rowData={rowData}\n        />,\n      )\n    }\n    return (\n      <div>\n        {rows}\n      </div>\n    )\n  }\n}\n\nTable.propTypes = {\n  x: PropTypes.number.isRequired,\n  y: PropTypes.number.isRequired,\n}"]},"metadata":{},"sourceType":"module"}