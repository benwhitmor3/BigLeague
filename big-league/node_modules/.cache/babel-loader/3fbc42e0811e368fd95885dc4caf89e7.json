{"ast":null,"code":"import { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./printDebugValue\";\nimport { createTrackingData, recordReactionAsCommitted, scheduleCleanupOfReactionIfLeaked } from \"./reactionCleanupTracking\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useForceUpdate } from \"./utils\";\nimport { useQueuedForceUpdate, useQueuedForceUpdateBlock } from \"./useQueuedForceUpdate\";\nvar EMPTY_OBJECT = {};\nfunction observerComponentNameFor(baseComponentName) {\n  return \"observer\" + baseComponentName;\n}\nexport function useObserver(fn, baseComponentName, options) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n  if (options === void 0) {\n    options = EMPTY_OBJECT;\n  }\n  if (isUsingStaticRendering()) {\n    return fn();\n  }\n  var wantedForceUpdateHook = options.useForceUpdate || useForceUpdate;\n  var forceUpdate = wantedForceUpdateHook();\n  var queuedForceUpdate = useQueuedForceUpdate(forceUpdate);\n  // StrictMode/ConcurrentMode/Suspense may mean that our component is\n  // rendered and abandoned multiple times, so we need to track leaked\n  // Reactions.\n  var reactionTrackingRef = React.useRef(null);\n  if (!reactionTrackingRef.current) {\n    // First render for this component (or first time since a previous\n    // reaction from an abandoned render was disposed).\n    var newReaction_1 = new Reaction(observerComponentNameFor(baseComponentName), function () {\n      // Observable has changed, meaning we want to re-render\n      // BUT if we're a component that hasn't yet got to the useEffect()\n      // stage, we might be a component that _started_ to render, but\n      // got dropped, and we don't want to make state changes then.\n      // (It triggers warnings in StrictMode, for a start.)\n      if (trackingData_1.mounted) {\n        // We have reached useEffect(), so we're mounted, and can trigger an update\n        queuedForceUpdate();\n      } else {\n        // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n        // when (and if) useEffect() arrives.  The easiest way to do that is just to\n        // drop our current reaction and allow useEffect() to recreate it.\n        newReaction_1.dispose();\n        reactionTrackingRef.current = null;\n      }\n    });\n    var trackingData_1 = createTrackingData(newReaction_1);\n    reactionTrackingRef.current = trackingData_1;\n    scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);\n  }\n  var reaction = reactionTrackingRef.current.reaction;\n  React.useDebugValue(reaction, printDebugValue);\n  React.useEffect(function () {\n    // Called on first mount only\n    recordReactionAsCommitted(reactionTrackingRef);\n    if (reactionTrackingRef.current) {\n      // Great. We've already got our reaction from our render;\n      // all we need to do is to record that it's now mounted,\n      // to allow future observable changes to trigger re-renders\n      reactionTrackingRef.current.mounted = true;\n    } else {\n      // The reaction we set up in our render has been disposed.\n      // This is either due to bad timings of renderings, e.g. our\n      // component was paused for a _very_ long time, and our\n      // reaction got cleaned up, or we got a observable change\n      // between render and useEffect\n      // Re-create the reaction\n      reactionTrackingRef.current = {\n        reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n          // We've definitely already been mounted at this point\n          queuedForceUpdate();\n        }),\n        cleanAt: Infinity\n      };\n      queuedForceUpdate();\n    }\n    return function () {\n      reactionTrackingRef.current.reaction.dispose();\n      reactionTrackingRef.current = null;\n    };\n  }, []);\n  // delay all force-update calls after rendering of this component\n  return useQueuedForceUpdateBlock(function () {\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    var rendering;\n    var exception;\n    reaction.track(function () {\n      try {\n        rendering = fn();\n      } catch (e) {\n        exception = e;\n      }\n    });\n    if (exception) {\n      throw exception; // re-throw any exceptions caught during rendering\n    }\n\n    return rendering;\n  });\n}","map":{"version":3,"names":["Reaction","React","printDebugValue","createTrackingData","recordReactionAsCommitted","scheduleCleanupOfReactionIfLeaked","isUsingStaticRendering","useForceUpdate","useQueuedForceUpdate","useQueuedForceUpdateBlock","EMPTY_OBJECT","observerComponentNameFor","baseComponentName","useObserver","fn","options","wantedForceUpdateHook","forceUpdate","queuedForceUpdate","reactionTrackingRef","useRef","current","newReaction_1","trackingData_1","mounted","dispose","reaction","useDebugValue","useEffect","cleanAt","Infinity","rendering","exception","track","e"],"sources":["/Users/bwhitmore6/Desktop/Projects/BigLeague/node_modules/mobx-react-lite/es/useObserver.js"],"sourcesContent":["import { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./printDebugValue\";\nimport { createTrackingData, recordReactionAsCommitted, scheduleCleanupOfReactionIfLeaked } from \"./reactionCleanupTracking\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useForceUpdate } from \"./utils\";\nimport { useQueuedForceUpdate, useQueuedForceUpdateBlock } from \"./useQueuedForceUpdate\";\nvar EMPTY_OBJECT = {};\nfunction observerComponentNameFor(baseComponentName) {\n    return \"observer\" + baseComponentName;\n}\nexport function useObserver(fn, baseComponentName, options) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (options === void 0) { options = EMPTY_OBJECT; }\n    if (isUsingStaticRendering()) {\n        return fn();\n    }\n    var wantedForceUpdateHook = options.useForceUpdate || useForceUpdate;\n    var forceUpdate = wantedForceUpdateHook();\n    var queuedForceUpdate = useQueuedForceUpdate(forceUpdate);\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    var reactionTrackingRef = React.useRef(null);\n    if (!reactionTrackingRef.current) {\n        // First render for this component (or first time since a previous\n        // reaction from an abandoned render was disposed).\n        var newReaction_1 = new Reaction(observerComponentNameFor(baseComponentName), function () {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (trackingData_1.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                queuedForceUpdate();\n            }\n            else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.  The easiest way to do that is just to\n                // drop our current reaction and allow useEffect() to recreate it.\n                newReaction_1.dispose();\n                reactionTrackingRef.current = null;\n            }\n        });\n        var trackingData_1 = createTrackingData(newReaction_1);\n        reactionTrackingRef.current = trackingData_1;\n        scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);\n    }\n    var reaction = reactionTrackingRef.current.reaction;\n    React.useDebugValue(reaction, printDebugValue);\n    React.useEffect(function () {\n        // Called on first mount only\n        recordReactionAsCommitted(reactionTrackingRef);\n        if (reactionTrackingRef.current) {\n            // Great. We've already got our reaction from our render;\n            // all we need to do is to record that it's now mounted,\n            // to allow future observable changes to trigger re-renders\n            reactionTrackingRef.current.mounted = true;\n        }\n        else {\n            // The reaction we set up in our render has been disposed.\n            // This is either due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up, or we got a observable change\n            // between render and useEffect\n            // Re-create the reaction\n            reactionTrackingRef.current = {\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n                    // We've definitely already been mounted at this point\n                    queuedForceUpdate();\n                }),\n                cleanAt: Infinity\n            };\n            queuedForceUpdate();\n        }\n        return function () {\n            reactionTrackingRef.current.reaction.dispose();\n            reactionTrackingRef.current = null;\n        };\n    }, []);\n    // delay all force-update calls after rendering of this component\n    return useQueuedForceUpdateBlock(function () {\n        // render the original component, but have the\n        // reaction track the observables, so that rendering\n        // can be invalidated (see above) once a dependency changes\n        var rendering;\n        var exception;\n        reaction.track(function () {\n            try {\n                rendering = fn();\n            }\n            catch (e) {\n                exception = e;\n            }\n        });\n        if (exception) {\n            throw exception; // re-throw any exceptions caught during rendering\n        }\n        return rendering;\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}